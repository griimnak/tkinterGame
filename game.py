try:
    # python2 fallback
    import Tkinter as tk
except ImportError:
    import tkinter as tk
import sys
import time
import math
import threading
import random

from os import path

# Working dictionary
GAME = {
    "health_points": 1000,
    "attack_power": 50,
    "shield_power": 0,
    "currency": 0,
    "currency_rare": 0,
    "is_dead": False,
    "deaths": 0,
    # start system variables
    "canvas_w": 1024,
    "canvas_h": 768,
    "canvas_tile_size": 32,
    "frame_rate": 100,
    "frame_rate_list": [],
    "frame_delay": 12  # 12ms
}


class Window(tk.Frame):
    """ the main game window generated by tkinter """
    def __init__(self, *args, **kwargs):
        tk.Frame.__init__(self, *args, **kwargs)
        sys.stdout = self  # bind print() to the tk window

        self.log_area = tk.Text(self, height=7, width=40)
        self.log_scroll_bar = tk.Scrollbar(self, orient="vertical", command=self.log_area.yview)

        self.log_area.configure(yscrollcommand=self.log_scroll_bar.set)

        self.log_scroll_bar.pack(side="right", fill="y")
        self.log_area.pack(side="left", fill="both", expand=True)

    def write(self, txt):
        self.log_area.insert("end", str(txt))
        self.log_area.see("end")

    def flush(self):
        pass


class Player:
    """player object """
    def __init__(self, pos=(0, 0)):
        global GAME
        self.ts = GAME["canvas_tile_size"]  # tile size
        self.player_pos = list(pos)
        self.cursor_pos = list((0, 0))

    def move(self, event):
        """ controls """
        if event.char == "w" or event.char == "W":
            for wall in walls:
                if self.player_pos[1]-1 == wall[1] and wall[0] == self.player_pos[0]:
                    return False
            self.player_pos[1] -= 1
        if event.char == "s" or event.char == "S":
            for wall in walls:
                if self.player_pos[1]+1 == wall[1] and wall[0] == self.player_pos[0]:
                    return False
            self.player_pos[1] += 1
        if event.char == "a" or event.char == "A":
            for wall in walls:
                if self.player_pos[1] == wall[1] and wall[0] == self.player_pos[0]-1:
                    return False
            self.player_pos[0] -= 1
        if event.char == "d" or event.char == "D":
            for wall in walls:
                if self.player_pos[1] == wall[1] and wall[0] == self.player_pos[0]+1:
                    return False
            self.player_pos[0] += 1

    def motion(self, event):
        """ updates cursor position """
        self.cursor_pos[0] = event.x/self.ts + 0.500; self.cursor_pos[1] = event.y/self.ts + 0.500  # x;y
        # print("[DEBUG] cursor:(x:", self.cursor_pos[0], " y:", self.cursor_pos[1], ")")

    def draw(self):
        """ draw our player positions """
        canvas.create_rectangle(
            (self.player_pos[0]*self.ts-self.ts, self.player_pos[1]*self.ts-self.ts,  # draw player position
             self.player_pos[0]*self.ts, self.player_pos[1]*self.ts), fill="#fff")

        canvas.create_rectangle(
            (self.cursor_pos[0]*self.ts-self.ts, self.cursor_pos[1]*self.ts-self.ts,  # draw cursor position
             self.cursor_pos[0]*self.ts, self.cursor_pos[1]*self.ts), fill="blue")


def game_loop():
    global GAME
    timer = time.time()
    canvas.delete("all")  # delete all canvas elements for redraw
    root.title("idkgame   FPS:" + str(GAME["frame_rate"])[0:6])  # update fps
    draw_grid()  # draw grid system
    _draw_walls()  # terrain
    player.draw()  # draw player location

    # fps update
    timer_end = time.time()
    GAME["frame_rate_list"].append(float(timer_end - timer))
    if len(GAME["frame_rate_list"]) == 30:
        try:
            GAME["frame_rate"] = str(1 / (sum(GAME["frame_rate_list"]) / 30))
        except:
            GAME["frame_rate"] = 1000
        else:
            GAME["frame_rate_list"] = []
    root.after(GAME["frame_delay"], game_loop)


class Wall:
    """ wall object creates un-passable grid points. """
    def __init__(self, pos=(0, 0)):
        self.pos = list(pos)

    def draw(self):
        global GAME
        ts = GAME["canvas_tile_size"]
        canvas.create_rectangle((self.pos[0]*ts-ts, self.pos[1]*ts-ts, self.pos[0]*ts, self.pos[1]*ts), fill="red")

        return self.pos


def draw_grid():
    """ draws the grid system """
    global GAME
    for x in range(0, GAME["canvas_w"], GAME["canvas_tile_size"]):
        canvas.create_line((x, 0, x, GAME["canvas_h"]), fill=_from_rgb((100, 100, 100)))
    for y in range(0, GAME["canvas_h"], GAME["canvas_tile_size"]):
        canvas.create_line((0, y, GAME["canvas_w"], y), fill=_from_rgb((100, 100, 100)))


def _draw_walls():
    """draws walls"""
    global map_data, temp, walls
    temp = []
    for row, tiles in enumerate(map_data):
        for col, tile in enumerate(tiles):
            if tile == "1":
                walls += [Wall((col, row)).draw()]
    temp = walls


def _rotate2d(pos, rad):
    x, y = pos
    s, c = math.sin(rad), math.cos(rad)
    return x * c - y * s, y * c + x * s

def _from_rgb(rgb):
    """ rgb to tkinter friendly color code"""
    return "#%02x%02x%02x" % rgb


root = tk.Tk()
window = Window(root)

canvas = tk.Canvas(root, bg=_from_rgb((40, 40, 40)), width=GAME["canvas_w"], height=GAME["canvas_h"])

player = Player((10, 10))  # default spawn

game_folder = path.dirname(__file__)
walls = []
map_data = []

with open(path.join(game_folder, "map2.txt"), "rt") as map_file:
    for line in map_file:
        map_data.append(line)

canvas.bind_all("<Key>", player.move)
canvas.bind("<Motion>", player.motion)

canvas.pack(fill="none", expand=True)
window.pack(fill="both", expand=True)

# run loop
game_loop()
# game_threads()  #  This will be for randomized events
root.mainloop()
